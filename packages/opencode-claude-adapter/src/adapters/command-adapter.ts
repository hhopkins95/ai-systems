/**
 * Command Adapter
 *
 * Syncs Claude Code commands to OpenCode command format.
 * Commands are copied to .opencode/command/ with minimal transformation.
 *
 * - Adds header comment indicating source
 * - Preserves original frontmatter
 * - Preserves body content
 */

import type { Command, CommandWithSource } from "@ai-systems/shared-types";
import { mkdir, writeFile, readdir, rm } from "fs/promises";
import { join } from "path";
import matter from "gray-matter";

export interface SyncResult {
  written: string[];
  skipped: string[];
  errors: Array<{ file: string; error: string }>;
}

/**
 * Format a command file with header comment
 */
function formatCommandFile(command: CommandWithSource): string {
  const header = [
    "<!--",
    "  Auto-generated by opencode-claude-adapter",
    `  Source: ${command.source?.path}`,
    "  Do not edit - changes will be overwritten on next sync",
    "-->",
    "",
  ].join("\n");

  // Reconstruct the file with frontmatter
  const frontmatter = command.metadata;
  const body = command.content;

  // Use gray-matter to stringify frontmatter + content
  const fileContent = matter.stringify(body, frontmatter);

  return header + fileContent;
}

/**
 * Clear all contents of a directory
 */
async function clearDirectory(dir: string): Promise<void> {
  try {
    const entries = await readdir(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = join(dir, entry.name);
      await rm(fullPath, { recursive: true });
    }
  } catch {
    // Directory might not exist - that's fine
  }
}

/**
 * Sync commands to .opencode/command/ directory
 */
export async function syncCommands(
  commands: Command[],
  projectDir: string
): Promise<SyncResult> {
  const result: SyncResult = {
    written: [],
    skipped: [],
    errors: [],
  };

  const targetDir = join(projectDir, ".opencode", "command");

  // Ensure directory exists
  await mkdir(targetDir, { recursive: true });

  // Clear existing commands before syncing
  await clearDirectory(targetDir);

  if (commands.length === 0) {
    return result;
  }

  // Deduplicate commands by name (later sources override earlier)
  const commandMap = new Map<string, Command>();
  for (const command of commands) {
    commandMap.set(command.name, command);
  }

  // Write each command
  for (const [name, command] of commandMap) {
    const targetPath = join(targetDir, `${name}.md`);

    try {
      const content = formatCommandFile(command);
      await writeFile(targetPath, content, "utf-8");
      result.written.push(name);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      result.errors.push({ file: name, error: message });
    }
  }

  return result;
}
