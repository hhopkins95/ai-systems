/**
 * Agent Adapter
 *
 * Syncs Claude Code agents to OpenCode agent format.
 * Agents are copied to .opencode/agent/ with frontmatter transformation.
 *
 * Transformations:
 * - tools: ["read", "write"] â†’ tools: { read: true, write: true }
 * - Adds mode: "subagent" (default)
 * - Preserves description and body content
 */

import type { Agent, AgentWithSource } from "@ai-systems/shared-types";
import { mkdir, writeFile } from "fs/promises";
import { join } from "path";
import matter from "gray-matter";

export interface SyncResult {
  written: string[];
  skipped: string[];
  errors: Array<{ file: string; error: string }>;
}

/**
 * Parse tools from various formats:
 * - Array: ["read", "write"]
 * - Comma-separated string: "read, write"
 * - Single string: "read"
 */
function parseTools(tools: unknown): string[] {
  if (Array.isArray(tools)) {
    return tools.filter((t) => typeof t === "string");
  }
  if (typeof tools === "string") {
    return tools.split(",").map((t) => t.trim()).filter(Boolean);
  }
  return [];
}

/**
 * Transform Claude agent frontmatter to OpenCode format
 */
function transformAgentFrontmatter(
  claudeMetadata: Record<string, unknown>
): Record<string, unknown> {
  const opencode: Record<string, unknown> = {};

  // Copy description directly
  if (claudeMetadata.description) {
    opencode.description = claudeMetadata.description;
  }

  // Add mode (default to subagent)
  opencode.mode = "subagent";

  // Transform tools to object format
  if (claudeMetadata.tools) {
    const toolsList = parseTools(claudeMetadata.tools);
    if (toolsList.length > 0) {
      opencode.tools = {};
      for (const tool of toolsList) {
        (opencode.tools as Record<string, boolean>)[tool] = true;
      }
    }
  }

  // Copy model if present
  if (claudeMetadata.model) {
    opencode.model = claudeMetadata.model;
  }

  return opencode;
}

/**
 * Format an agent file with header comment and transformed frontmatter
 */
function formatAgentFile(agent: AgentWithSource): string {
  const header = [
    "<!--",
    "  Auto-generated by opencode-claude-adapter",
    `  Source: ${agent.source?.path}`,
    "  Do not edit - changes will be overwritten on next sync",
    "-->",
    "",
  ].join("\n");

  // Transform frontmatter
  const transformedFrontmatter = transformAgentFrontmatter(agent.metadata);
  const body = agent.content;

  // Use gray-matter to stringify frontmatter + content
  const fileContent = matter.stringify(body, transformedFrontmatter);

  return header + fileContent;
}

/**
 * Sync agents to .opencode/agent/ directory
 */
export async function syncAgents(
  agents: Agent[],
  projectDir: string
): Promise<SyncResult> {
  const result: SyncResult = {
    written: [],
    skipped: [],
    errors: [],
  };

  if (agents.length === 0) {
    return result;
  }

  const targetDir = join(projectDir, ".opencode", "agent");

  // Ensure directory exists
  try {
    await mkdir(targetDir, { recursive: true });
  } catch (error) {
    // Directory might already exist
  }

  // Deduplicate agents by name (later sources override earlier)
  const agentMap = new Map<string, Agent>();
  for (const agent of agents) {
    agentMap.set(agent.name, agent);
  }

  // Write each agent
  for (const [name, agent] of agentMap) {
    const targetPath = join(targetDir, `${name}.md`);

    try {
      const content = formatAgentFile(agent);
      await writeFile(targetPath, content, "utf-8");
      result.written.push(name);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      result.errors.push({ file: name, error: message });
    }
  }

  return result;
}
